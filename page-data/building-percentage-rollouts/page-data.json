{"componentChunkName":"component---src-templates-blog-post-js","path":"/building-percentage-rollouts/","result":{"data":{"site":{"siteMetadata":{"title":"The Curious Engineer"}},"markdownRemark":{"id":"acf098df-5643-53d2-b23f-76e58067d5ee","excerpt":"A few years back, a client of mine wanted a feature flagging solution and me and my team were asked to interview and pick a suitable vendor. We set up a call…","html":"<p>A few years back, a client of mine wanted a feature flagging solution and me and my team were asked to interview and pick a suitable vendor. We set up a call with a few vendors and quickly realised that the client wanted only a subset of features that these enterprise solutions were offering and going with these solutions meant they were unnecessarily going to be paying for things they don’t actually need and will not need in the foreseeable future. It was also clear that we would be kinda vendor-locked as our flags grew, and these systems don’t make it easy to export flags (with all the configs) into a different one.</p>\n<p>At this point, I was already thinking if we could build this in-house but before pitching it to the client, the only feature that was a question mark in my head was the percentage rollout. I did not have a clear idea on how to go about building it.</p>\n<p>For those of you who don’t know, a feature can be turned on only for a subset of users before it’s available to everyone, for example, say, only 70% of the user base. This is called percentage rollouts.</p>\n<ul>\n<li>At any point in time, the percentage can be increased or decreased</li>\n<li>It can be converted into a normal feature flag which can turn on for all users or none at all</li>\n</ul>\n<h3>The Problem</h3>\n<p>When thinking about building this out, my first idea was,</p>\n<ul>\n<li>Store everything in the DB, say when <code class=\"language-text\">flag-1</code> is turned on for <code class=\"language-text\">70%</code> of users,</li>\n<li>Each flag has an association with every user whether it is <code class=\"language-text\">on</code> or <code class=\"language-text\">off</code> for that user</li>\n</ul>\n<p>Sure, but I quickly realised this doesn’t scale,</p>\n<ul>\n<li>Changing 70% → 30% requires scanning/updating large user sets in the DB</li>\n<li>New users added, demand backfills across all existing flags to maintain the target percentage</li>\n</ul>\n<p>So it became obvious that we needed a stateless solution since maintaining state is cumbersome in this case. However, with a stateless solution, we should ensure,</p>\n<ol>\n<li><strong>Stickiness</strong>: The same user should land on the same side of the threshold every time. If flag-1 is at, say, 70%, a user who’s “in” stays in across sessions and as new users join. The outcome shouldn’t flap between logins.</li>\n<li><strong>Cheap to compute</strong>: Which side of the threshold the user falls on should be easily computable (ideally O(1)); if it’s slow, that latency cascades to the endpoints behind the flag</li>\n</ol>\n<p>So, how do we actually solve this?</p>\n<h3>Solution</h3>\n<p>After seeing a discussion about how large hash-like numbers can be treated as uniformly distributed, the core idea emerged,</p>\n<p>First thought was, can we convert the user email into these large pseudo-random number? This could serve as the basis for bucketing users into the rollout percentage</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\">user_hash <span class=\"token operator\">=</span> hashlib<span class=\"token punctuation\">.</span>sha1<span class=\"token punctuation\">(</span><span class=\"token string\">\"abc@gmail.com\"</span><span class=\"token punctuation\">.</span>encode<span class=\"token punctuation\">(</span><span class=\"token string\">\"utf-8\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>hexdigest<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\nc0d0a32c405c68cb538e3891a3e3bce98887f012 <span class=\"token comment\"># which will produce a hash like this</span></code></pre></div>\n<p>Cryptographic hashes (like SHA-1) are designed so that tiny input changes produce seemingly unrelated outputs (or you could also use a UUID associated with the user to produce a similar effect).</p>\n<p>Now that we have a pseudo-random number, we can bucket it across the available percentage by taking a mod of 100, as shown below</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\">num_user_hash <span class=\"token operator\">=</span> <span class=\"token builtin\">int</span><span class=\"token punctuation\">(</span>user_hash<span class=\"token punctuation\">,</span> <span class=\"token number\">16</span><span class=\"token punctuation\">)</span>\nscore <span class=\"token operator\">=</span> num_user_hash <span class=\"token operator\">%</span> <span class=\"token number\">100</span></code></pre></div>\n<p>The reason this works because a cryptographic hash behaves like a gigantic fair dice roll, its 160-bit output is spread almost perfectly evenly across all possible values, so when we take that huge number mod 100, each of the 100 possible remainders shows up about 1 % of the time, meaning the first N remainders reliably give the flag to ~N % of users.</p>\n<p>We can use this to determine whether the flag is on or off, based on whether the score is within the set percentage of the flag or not.\nYou can try it yourself with the code below—it prints how many users get the feature for a given rollout percentage.</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">import</span> hashlib\n\nTOTAL_USERS <span class=\"token operator\">=</span> <span class=\"token number\">1000000</span>\nROLLOUT_PERCENTAGE <span class=\"token operator\">=</span> <span class=\"token number\">30</span>\n\n<span class=\"token comment\"># assuming list of users</span>\nusers <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">for</span> number <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span>TOTAL_USERS<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n  users<span class=\"token punctuation\">[</span><span class=\"token string\">'{}@gmail.com'</span><span class=\"token punctuation\">.</span><span class=\"token builtin\">format</span><span class=\"token punctuation\">(</span>number<span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token boolean\">True</span>\n\n<span class=\"token keyword\">def</span> <span class=\"token function\">get_flag_value</span><span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n  <span class=\"token keyword\">if</span> users<span class=\"token punctuation\">[</span>key<span class=\"token punctuation\">]</span><span class=\"token punctuation\">:</span>\n    user_hash <span class=\"token operator\">=</span> hashlib<span class=\"token punctuation\">.</span>sha1<span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">.</span>encode<span class=\"token punctuation\">(</span><span class=\"token string\">\"utf-8\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>hexdigest<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token comment\"># produce the hash with the email</span>\n    num_user_hash <span class=\"token operator\">=</span> <span class=\"token builtin\">int</span><span class=\"token punctuation\">(</span>user_hash<span class=\"token punctuation\">,</span> <span class=\"token number\">16</span><span class=\"token punctuation\">)</span> <span class=\"token comment\"># convert it to a number</span>\n    score <span class=\"token operator\">=</span> num_user_hash <span class=\"token operator\">%</span> <span class=\"token number\">100</span> <span class=\"token comment\"># take modulo to see where the user falls</span>\n    <span class=\"token keyword\">return</span> score <span class=\"token operator\">&lt;</span> ROLLOUT_PERCENTAGE <span class=\"token comment\"># return whether the flag should be on or off for the user</span>\n\n<span class=\"token comment\"># tests</span>\n<span class=\"token keyword\">if</span> __name__ <span class=\"token operator\">==</span> <span class=\"token string\">'__main__'</span><span class=\"token punctuation\">:</span>\n  total_true <span class=\"token operator\">=</span> <span class=\"token number\">0</span>\n  <span class=\"token keyword\">for</span> user <span class=\"token keyword\">in</span> users<span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">if</span> get_flag_value<span class=\"token punctuation\">(</span>user<span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> <span class=\"token boolean\">True</span><span class=\"token punctuation\">:</span>\n      total_true <span class=\"token operator\">+=</span> <span class=\"token number\">1</span>\n  <span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">'true'</span><span class=\"token punctuation\">,</span> total_true<span class=\"token punctuation\">)</span></code></pre></div>\n<p>This way, we ensure,</p>\n<ol>\n<li><strong>Stickiness</strong>: Since same user is going to produce the same hash and fall within the same bucket</li>\n<li><strong>Cheap to compute</strong>: Relatively cheap to calculate during a user’s request. Also increasing the percentage for a flag, simple adds more users while existing users are unchanged which is exactly what we want</li>\n</ol>\n<p>There’s one catch: because the percentage is calculated from a fixed input (email here), all flags would select the same users at a given percentage. We would ideally want different set of users to participate in different experiments. So, we could add a salt that it’s unique to a feature flag when calculating the hash in order to get different user sets per flag, like so,</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\">key <span class=\"token operator\">=</span> <span class=\"token string-interpolation\"><span class=\"token string\">f\"</span><span class=\"token interpolation\"><span class=\"token punctuation\">{</span>flag_id<span class=\"token punctuation\">}</span></span><span class=\"token string\">:</span><span class=\"token interpolation\"><span class=\"token punctuation\">{</span>user_email<span class=\"token punctuation\">}</span></span><span class=\"token string\">\"</span></span>\nuser_hash <span class=\"token operator\">=</span> hashlib<span class=\"token punctuation\">.</span>sha1<span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">.</span>encode<span class=\"token punctuation\">(</span><span class=\"token string\">\"utf-8\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>hexdigest<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></code></pre></div>\n<h3>Other Minor Improvements</h3>\n<ul>\n<li>Instead of having flag_id as the salt, you could also have different unique column, so if there’s a situation where we need same set of users for two or more flags, we could reuse the same salt so that users are grouped the same way</li>\n<li>Bucket to 10,000 instead of 100 for smoother ramps and fewer visible jumps on small inputs</li>\n<li>Prefer a UUID or any other hash of any other user-id, if emails change</li>\n</ul>\n<p>The solution ended up being delivered at 1/5th of the cost of the commercial solutions in less than 6-7 weeks with respective SDKs without worry about vendor lock-in and with just the feature set they need.</p>","frontmatter":{"title":"Building Reliable Percentage Rollouts In-House","date":"July 31, 2025","description":null}},"previous":null,"next":{"fields":{"slug":"/decoupling-aws-cloudformation-templates/"},"frontmatter":{"title":"Decoupling AWS CloudFormation Templates"}}},"pageContext":{"id":"acf098df-5643-53d2-b23f-76e58067d5ee","previousPostId":null,"nextPostId":"79a93487-e104-5ae6-ad80-aca2f0de37b3"}},"staticQueryHashes":["2841359383"],"slicesMap":{}}