{"componentChunkName":"component---src-templates-blog-post-js","path":"/building-percentage-rollouts/","result":{"data":{"site":{"siteMetadata":{"title":"The Curious Engineer"}},"markdownRemark":{"id":"acf098df-5643-53d2-b23f-76e58067d5ee","excerpt":"A few years back, my team was tasked with building a feature flagging platform, primarily for A/B testing and introducing features slowly based on reception…","html":"<p>A few years back, my team was tasked with building a feature flagging platform, primarily for A/B testing and introducing features slowly based on reception. The only feature that was a question mark in my head was the percentage rollout. I did not have a clear idea on how to go about building it.</p>\n<p>For those of you who don’t know, a feature can be turned on only for a subset of users before it’s available to everyone, for example, say, only 70% of the user base. This is called percentage rollouts.</p>\n<ul>\n<li>At any point in time, the percentage can be increased or decreased</li>\n<li>It can be converted into a normal feature flag which can turn on for all users or none at all</li>\n</ul>\n<h3>The Problem</h3>\n<p>When thinking about building this out, my first idea was,</p>\n<ul>\n<li>Store everything in the DB, say when <code class=\"language-text\">flag-1</code> is turned on for <code class=\"language-text\">70%</code> of users,</li>\n<li>Each flag has an association with every user whether it is <code class=\"language-text\">on</code> or <code class=\"language-text\">off</code> for that user</li>\n</ul>\n<p>Sure, but I quickly realised this doesn’t scale,</p>\n<ul>\n<li>Changing 70% → 30% requires scanning/updating large user sets in the DB</li>\n<li>New users added, demand backfills across all existing flags to maintain the target percentage</li>\n</ul>\n<p>So it became obvious that we needed a stateless solution since maintaining state of each flag is cumbersome in this case. However, with a stateless solution, we should ensure,</p>\n<ol>\n<li><strong>Stickiness</strong>: The same user should land on the same side of the threshold every time. If flag-1 is at, say, 70%, a user who’s “in” stays in across sessions and as new users join. The outcome shouldn’t flap between logins.</li>\n<li><strong>Cheap to compute</strong>: Which side of the threshold the user falls on should be easily computable (ideally O(1)) on the fly (since we will no longer have state stored in DB to simply retrieve it); if it’s slow, that latency cascades to the endpoints behind the flag</li>\n</ol>\n<p>So, how do we actually solve this?</p>\n<h3>Solution</h3>\n<p>After seeing a discussion about how large hash-like numbers can be treated as uniformly distributed, the core idea emerged,</p>\n<p>First thought was, can we convert the user email into these large pseudo-random number? This could serve as the basis for bucketing users into the rollout percentage</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\">user_hash <span class=\"token operator\">=</span> hashlib<span class=\"token punctuation\">.</span>sha1<span class=\"token punctuation\">(</span><span class=\"token string\">\"abc@gmail.com\"</span><span class=\"token punctuation\">.</span>encode<span class=\"token punctuation\">(</span><span class=\"token string\">\"utf-8\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>hexdigest<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\nc0d0a32c405c68cb538e3891a3e3bce98887f012 <span class=\"token comment\"># which will produce a hash like this</span></code></pre></div>\n<p>Cryptographic hashes (like SHA-1) are designed so that tiny input changes produce seemingly unrelated outputs (you could also use a UUID associated with the user to produce a similar effect).</p>\n<p>Now that we have a pseudo-random number, we can bucket it across the available percentage by taking a mod of 100, as shown below</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\">num_user_hash <span class=\"token operator\">=</span> <span class=\"token builtin\">int</span><span class=\"token punctuation\">(</span>user_hash<span class=\"token punctuation\">,</span> <span class=\"token number\">16</span><span class=\"token punctuation\">)</span>\nscore <span class=\"token operator\">=</span> num_user_hash <span class=\"token operator\">%</span> <span class=\"token number\">100</span></code></pre></div>\n<p>The reason this works because a cryptographic hash behaves like a gigantic fair dice roll, its 160-bit output is spread almost perfectly evenly across all possible values, so when we take that huge number mod 100, each of the 100 possible remainders shows up about 1 % of the time, meaning the first N remainders reliably give the flag to ~N % of users.</p>\n<p>We can use this to determine whether the flag is on or off, based on whether the score is within the set percentage of the flag or not.\nYou can try it yourself with the code below—it prints how many of <code class=\"language-text\">1000000</code> users get the feature flag turned on for a given rollout percentage.</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">import</span> hashlib\n\nTOTAL_USERS <span class=\"token operator\">=</span> <span class=\"token number\">1000000</span>\nROLLOUT_PERCENTAGE <span class=\"token operator\">=</span> <span class=\"token number\">30</span>\n\n<span class=\"token comment\"># assuming list of users</span>\nusers <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">for</span> number <span class=\"token keyword\">in</span> <span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span>TOTAL_USERS<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n  users<span class=\"token punctuation\">[</span><span class=\"token string\">'{}@gmail.com'</span><span class=\"token punctuation\">.</span><span class=\"token builtin\">format</span><span class=\"token punctuation\">(</span>number<span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token boolean\">True</span>\n\n<span class=\"token keyword\">def</span> <span class=\"token function\">get_flag_value</span><span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n  <span class=\"token keyword\">if</span> users<span class=\"token punctuation\">[</span>key<span class=\"token punctuation\">]</span><span class=\"token punctuation\">:</span>\n    user_hash <span class=\"token operator\">=</span> hashlib<span class=\"token punctuation\">.</span>sha1<span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">.</span>encode<span class=\"token punctuation\">(</span><span class=\"token string\">\"utf-8\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>hexdigest<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token comment\"># produce the hash with the email</span>\n    num_user_hash <span class=\"token operator\">=</span> <span class=\"token builtin\">int</span><span class=\"token punctuation\">(</span>user_hash<span class=\"token punctuation\">,</span> <span class=\"token number\">16</span><span class=\"token punctuation\">)</span> <span class=\"token comment\"># convert it to a number</span>\n    score <span class=\"token operator\">=</span> num_user_hash <span class=\"token operator\">%</span> <span class=\"token number\">100</span> <span class=\"token comment\"># take modulo to see where the user falls</span>\n    <span class=\"token keyword\">return</span> score <span class=\"token operator\">&lt;</span> ROLLOUT_PERCENTAGE <span class=\"token comment\"># return whether the flag should be on or off for the user</span>\n\n<span class=\"token comment\"># tests</span>\n<span class=\"token keyword\">if</span> __name__ <span class=\"token operator\">==</span> <span class=\"token string\">'__main__'</span><span class=\"token punctuation\">:</span>\n  total_true <span class=\"token operator\">=</span> <span class=\"token number\">0</span>\n  <span class=\"token keyword\">for</span> user <span class=\"token keyword\">in</span> users<span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">if</span> get_flag_value<span class=\"token punctuation\">(</span>user<span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> <span class=\"token boolean\">True</span><span class=\"token punctuation\">:</span>\n      total_true <span class=\"token operator\">+=</span> <span class=\"token number\">1</span>\n  <span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string-interpolation\"><span class=\"token string\">f'Flag turned on for: </span><span class=\"token interpolation\"><span class=\"token punctuation\">{</span>total_true<span class=\"token punctuation\">}</span></span><span class=\"token string\"> users'</span></span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>Running the above script should show you,</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Flag turned on for: 300105 users</code></pre></div>\n<p>This way, we ensure,</p>\n<ol>\n<li><strong>Stickiness</strong>: Since same user is going to produce the same hash and fall within the same bucket</li>\n<li><strong>Cheap to compute</strong>: Relatively cheap to calculate during a user’s request. Also increasing the percentage for a flag, simple adds more users while existing users are unchanged which is exactly what we want</li>\n</ol>\n<p>There’s one catch: because the percentage is calculated from a fixed input (email here), <strong>all</strong> feature flags would select the same users at a given percentage. We would ideally want different set of users to participate in different experiments. So, we could add a salt that it’s unique to a feature flag when calculating the hash in order to get different user sets per flag, like so,</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\">key <span class=\"token operator\">=</span> <span class=\"token string-interpolation\"><span class=\"token string\">f\"</span><span class=\"token interpolation\"><span class=\"token punctuation\">{</span>flag_id<span class=\"token punctuation\">}</span></span><span class=\"token string\">:</span><span class=\"token interpolation\"><span class=\"token punctuation\">{</span>user_email<span class=\"token punctuation\">}</span></span><span class=\"token string\">\"</span></span>\nuser_hash <span class=\"token operator\">=</span> hashlib<span class=\"token punctuation\">.</span>sha1<span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">.</span>encode<span class=\"token punctuation\">(</span><span class=\"token string\">\"utf-8\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>hexdigest<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></code></pre></div>\n<h3>Other Minor Improvements</h3>\n<ul>\n<li>Instead of having flag_id as the salt, you could also have different unique column, so if there’s a situation where we need same set of users for two or more flags, we could reuse the same salt so that users are grouped the same way</li>\n<li>Bucket to 10,000 instead of 100 for smoother ramps and fewer visible jumps on small inputs</li>\n<li>Prefer a UUID or any other hash of any other user-id, if emails change</li>\n</ul>","timeToRead":4,"frontmatter":{"title":"Building Reliable Percentage Rollouts In-House","date":"July 31, 2025","description":null}},"previous":{"fields":{"slug":"/aws-ai-league/"},"frontmatter":{"title":"Building, Breaking, and Tuning - My Experience at the AWS AI League"}},"next":{"fields":{"slug":"/decoupling-aws-cloudformation-templates/"},"frontmatter":{"title":"Decoupling AWS CloudFormation Templates"}}},"pageContext":{"id":"acf098df-5643-53d2-b23f-76e58067d5ee","previousPostId":"6b0a4a89-1be2-5caa-a9fa-d2f32ae8110f","nextPostId":"79a93487-e104-5ae6-ad80-aca2f0de37b3"}},"staticQueryHashes":["2841359383"],"slicesMap":{}}